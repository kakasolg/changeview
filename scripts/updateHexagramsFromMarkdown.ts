// filepath: d:\dev\html-prj\thinking_lenses\change_view\scripts\updateHexagramsFromMarkdown.ts
import mongoose from 'mongoose';
import fs from 'fs/promises';
import path from 'path';
import Hexagram from '../src/models/Hexagram'; // Adjust path as needed
import connectDB from '../src/lib/database'; // Adjust path as needed

// Helper function to parse the name and koreanName from "Name (KoreanName)"
const parseNameAndKoreanName = (nameField: string): { name: string; koreanName?: string } => {
  nameField = nameField.replace(/\*\*/g, ''); // Remove bold markers like **
  const match = nameField.match(/([^（]+)（([^）]+)）/); // Matches "Name (KoreanName)"
  if (match && match[1] && match[2]) {
    return { name: match[1].trim(), koreanName: match[2].trim() };
  }
  return { name: nameField.trim() };
};

async function updateHexagrams() {
  let connection;
  try {
    console.log('Connecting to MongoDB...');
    connection = await connectDB();
    console.log('Successfully connected to MongoDB.');

    const filePath = path.join(process.cwd(), 'docs', 'mental_models.md');
    console.log(`Reading Markdown file from: ${filePath}`);
    const markdownContent = await fs.readFile(filePath, 'utf-8');
    const lines = markdownContent.split('\n');

    const hexagramDataToProcess = [];
    let tableStarted = false;
    let headerSkipped = false;

    console.log('Parsing Markdown content...');
    for (const line of lines) {
      if (line.startsWith('|---|')) { // Table header separator
        tableStarted = true;
        headerSkipped = false; // Reset for tables that might not have a visual header row but use this separator
        continue;
      }

      if (!tableStarted || !line.startsWith('|')) {
        continue;
      }

      // Skip the actual header row "번호 | 괘상 | ..."
      if (!headerSkipped && (line.includes('**번호**') || line.includes('번호'))) {
          headerSkipped = true;
          continue;
      }
      if(!headerSkipped) { // If a separator was found, but no explicit header, assume first data row is next
          headerSkipped = true;
      }


      const cells = line.split('|').map(cell => cell.trim()).slice(1, -1); // Get content cells, remove outer empty cells

      if (cells.length >= 6) {
        const numberString = cells[0].replace(/\*\*/g, ''); // Remove bold markers from number
        const number = parseInt(numberString, 10);

        if (isNaN(number)) {
          // console.log(`Skipping row due to invalid number: ${cells[0]}`);
          continue; 
        }
        
        const parsedName = parseNameAndKoreanName(cells[2]);
        
        hexagramDataToProcess.push({
          number: number,
          symbol: cells[1].replace(/\*\*/g, ''),
          name: parsedName.name,
          koreanName: parsedName.koreanName,
          coreViewpoint: cells[3].replace(/\*\*/g, ''),
          mentalModels: cells[4].replace(/\*\*/g, '') === '-' ? '' : cells[4].replace(/\*\*/g, ''),
          summary: cells[5].replace(/\*\*/g, ''),
        });
      } else if (cells.length > 0 && cells[0] !== '') { // Log if a row looks like data but has too few cells
        // console.log(`Skipping row with insufficient cells: ${line}`);
      }
    }

    if (hexagramDataToProcess.length === 0) {
      console.log('No hexagram data found in Markdown or table format incorrect. Please check the Markdown file.');
      return;
    }

    console.log(`Found ${hexagramDataToProcess.length} hexagrams to process from Markdown.`);

    let updatedCount = 0;
    let createdCount = 0;
    const errors = [];

    for (const data of hexagramDataToProcess) {
      try {
        const existingHexagram = await Hexagram.findOne({ number: data.number });
        
        const updateData = {
          symbol: data.symbol,
          name: data.name,
          koreanName: data.koreanName,
          coreViewpoint: data.coreViewpoint,
          mentalModels: data.mentalModels,
          summary: data.summary,
          // keywords will be regenerated by pre-save hook if not present
        };

        if (existingHexagram) {
          await Hexagram.updateOne({ number: data.number }, { $set: updateData });
          updatedCount++;
        } else {
          await Hexagram.create({ ...data, ...updateData }); // Ensure all fields are present for creation
          createdCount++;
        }
      } catch (e: any) {
        console.error(`Error processing hexagram number ${data.number}:`, e.message);
        errors.push({ number: data.number, error: e.message });
      }
    }

    console.log('\n--- Update Summary ---');
    console.log(`Hexagrams successfully created: ${createdCount}`);
    console.log(`Hexagrams successfully updated: ${updatedCount}`);
    
    if (errors.length > 0) {
      console.error(`
Encountered ${errors.length} errors:`);
      errors.forEach(err => console.error(`- Hexagram ${err.number}: ${err.error}`));
    } else {
      console.log('All processed hexagrams were handled without errors.');
    }

  } catch (error: any) {
    console.error('\n--- Script Error ---');
    console.error('An error occurred during the script execution:', error);
  } finally {
    if (mongoose.connection.readyState === 1) {
      console.log('\nDisconnecting from MongoDB...');
      await mongoose.disconnect();
      console.log('Successfully disconnected.');
    }
  }
}

updateHexagrams();
